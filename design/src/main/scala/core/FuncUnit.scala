package core

import chisel3._
import chisel3.util._

class ALU(XLEN:Int=64) extends Module {
    val io = IO(new Bundle{
        val alu_op = Input(UInt(ALU_OP.width.W))
        val alu_in1 = Input(UInt(XLEN.W))
        val alu_in2 = Input(UInt(XLEN.W))
        val alu_out = Output(UInt(XLEN.W))
    })
    io.alu_out := 0.U
    switch(io.alu_op){
        is(ALU_OP.ADD.U){io.alu_out := io.alu_in1 + io.alu_in2}
        is(ALU_OP.SUB.U){io.alu_out := io.alu_in1 - io.alu_in2}
        is(ALU_OP.AND.U){io.alu_out := io.alu_in1 & io.alu_in2}
        is(ALU_OP.OR.U) {io.alu_out := io.alu_in1 | io.alu_in2}
        is(ALU_OP.XOR.U){io.alu_out := io.alu_in1 ^ io.alu_in2}
        is(ALU_OP.SLL.U){io.alu_out := io.alu_in1 << io.alu_in2(5,0)}
        is(ALU_OP.SRL.U){io.alu_out := io.alu_in1 >> io.alu_in2(5,0)}
        is(ALU_OP.SRA.U){io.alu_out := (io.alu_in1.asSInt >> io.alu_in2(5,0)).asUInt}
        is(ALU_OP.SLT.U){
            when(io.alu_in1.asSInt < io.alu_in2.asSInt){
                io.alu_out := 1.U
            }.otherwise{
                io.alu_out := 0.U
            }
        }
        is(ALU_OP.SLTU.U){
            when(io.alu_in1 < io.alu_in2){
                io.alu_out := 1.U
            }.otherwise{
                io.alu_out := 0.U
            }
        }
        is(ALU_OP.RS1.U){io.alu_out := io.alu_in1}
        is(ALU_OP.RS2.U){io.alu_out := io.alu_in2}
    }
}

class BRU (XLEN:Int=64) extends Module {
    val io = IO(new Bundle{
        val bru_op = Input(UInt(BRU_OP.width.W))
        val rs1_data = Input(UInt(XLEN.W))
        val rs2_data = Input(UInt(XLEN.W))
        val take_branch = Output(Bool())
    })
    io.take_branch := false.B
    switch(io.bru_op){
        is(BRU_OP.BEQ.U){
            io.take_branch := (io.rs1_data === io.rs2_data)
        }
        is(BRU_OP.BNE.U){
            io.take_branch := (io.rs1_data =/= io.rs2_data)
        }
        is(BRU_OP.BLT.U){
            io.take_branch := (io.rs1_data.asSInt < io.rs2_data.asSInt)
        }
        is(BRU_OP.BLTU.U){
            io.take_branch := (io.rs1_data < io.rs2_data)
        }
        is(BRU_OP.BGE.U){
            io.take_branch := (io.rs1_data.asSInt >= io.rs2_data.asSInt)
        }
        is(BRU_OP.BGEU.U){
            io.take_branch := (io.rs1_data >= io.rs2_data)
        }
    }
}
/**
  * Jump Address Unit
  * return address generated by instruction 
  *
  * @param XLEN
  */
class JAU (XLEN:Int=64) extends Module{
    val io = IO(new Bundle{
        val sel_jpc_i = Input(UInt(SEL_JPC_I.width.W))
        val sel_jpc_o = Input(UInt(SEL_JPC_O.width.W))
        val pc = Input(UInt(XLEN.W))
        val rs1_data = Input(UInt(XLEN.W))
        val imm = Input(UInt(XLEN.W))
        val jmp_addr = Output(UInt(XLEN.W))
    })
    val jpc_i = WireDefault(0.U(XLEN.W))
    val jpc_o = WireDefault(0.U(XLEN.W))
    //input selection
    jpc_i := MuxLookup(io.sel_jpc_i, 0.U)(
        Seq(
            SEL_JPC_I.PC.U -> io.pc,
            SEL_JPC_I.RS1.U -> io.rs1_data
        )
    )
    //output selection
    jpc_o := MuxLookup(io.sel_jpc_o, 0.U)(
        Seq(
            SEL_JPC_O.Normal.U -> (jpc_i + io.imm),
            SEL_JPC_O.Jalr.U   -> ((jpc_i + io.imm) & (~1.U(XLEN.W)))
        )
    )
    io.jmp_addr := jpc_o
}

class ImmGen(XLEN:Int=32) extends Module {
    val io = IO(new Bundle{
        val inst = Input(UInt(32.W))
        val imm    = Output(UInt(XLEN.W))
        val type_sel = Input(UInt(IMM_TYPE.width.W))
    })
    val immi = Fill(XLEN-11,io.inst(31)) ## io.inst(30,20)
    val imms = Fill(XLEN-11,io.inst(31)) ## io.inst(30,25) ## io.inst(11,7)
    val immb = Fill(XLEN-12,io.inst(31)) ## io.inst(7) ## io.inst(30,25) ## io.inst(11,8) ## false.B
    val immj = Fill(XLEN-20,io.inst(31)) ## io.inst(19,12) ## io.inst(20) ## io.inst(30,21) ## false.B
    val immu = Fill(XLEN-32,io.inst(31)) ## io.inst(31,12) ## Fill(12,false.B)
    val imm_csr = Fill(XLEN-5,0.U) ## io.inst(19,15)
    io.imm := 0.U
    io.imm := MuxLookup(io.type_sel, 0.U)(
        Seq(
            IMM_TYPE.I_Type.U -> immi,
            IMM_TYPE.S_Type.U -> imms,
            IMM_TYPE.B_Type.U -> immb,
            IMM_TYPE.U_Type.U -> immu,
            IMM_TYPE.J_Type.U -> immj,
            IMM_TYPE.CSR_Type.U -> imm_csr
        )
    )
}

