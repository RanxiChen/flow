package core

import chisel3._
import chisel3.util._

class ALU(XLEN:Int=64) extends Module {
    val io = IO(new Bundle{
        val alu_op = Input(UInt(ALU_OP.width.W))
        val alu_in1 = Input(UInt(XLEN.W))
        val alu_in2 = Input(UInt(XLEN.W))
        val alu_out = Output(UInt(XLEN.W))
    })
    io.alu_out := 0.U
    switch(io.alu_op){
        is(ALU_OP.ADD.U){io.alu_out := io.alu_in1 + io.alu_in2}
        is(ALU_OP.SUB.U){io.alu_out := io.alu_in1 - io.alu_in2}
        is(ALU_OP.AND.U){io.alu_out := io.alu_in1 & io.alu_in2}
        is(ALU_OP.OR.U) {io.alu_out := io.alu_in1 | io.alu_in2}
        is(ALU_OP.XOR.U){io.alu_out := io.alu_in1 ^ io.alu_in2}
        is(ALU_OP.SLL.U){io.alu_out := io.alu_in1 << io.alu_in2(5,0)}
        is(ALU_OP.SRL.U){io.alu_out := io.alu_in1 >> io.alu_in2(5,0)}
        is(ALU_OP.SRA.U){io.alu_out := (io.alu_in1.asSInt >> io.alu_in2(5,0)).asUInt}
        is(ALU_OP.SLT.U){
            when(io.alu_in1.asSInt < io.alu_in2.asSInt){
                io.alu_out := 1.U
            }.otherwise{
                io.alu_out := 0.U
            }
        }
        is(ALU_OP.SLTU.U){
            when(io.alu_in1 < io.alu_in2){
                io.alu_out := 1.U
            }.otherwise{
                io.alu_out := 0.U
            }
        }
    }
}

class BRU (XLEN:Int=64) extends Module {
    val io = IO(new Bundle{
        val bru_op = Input(UInt(BRU_OP.width.W))
        val rs1_data = Input(UInt(XLEN.W))
        val rs2_data = Input(UInt(XLEN.W))
        val take_branch = Output(Bool())
    })
    io.take_branch := false.B
    switch(io.bru_op){
        is(BRU_OP.BEQ.U){
            io.take_branch := (io.rs1_data === io.rs2_data)
        }
        is(BRU_OP.BNE.U){
            io.take_branch := (io.rs1_data =/= io.rs2_data)
        }
        is(BRU_OP.BLT.U){
            io.take_branch := (io.rs1_data.asSInt < io.rs2_data.asSInt)
        }
        is(BRU_OP.BLTU.U){
            io.take_branch := (io.rs1_data < io.rs2_data)
        }
        is(BRU_OP.BGE.U){
            io.take_branch := (io.rs1_data.asSInt >= io.rs2_data.asSInt)
        }
        is(BRU_OP.BGEU.U){
            io.take_branch := (io.rs1_data >= io.rs2_data)
        }
    }
}
/**
  * Jump Address Unit
  * return address generated by instruction 
  *
  * @param XLEN
  */
class JAU (XLEN:Int=64) extends Module{
    val io = IO(new Bundle{
        val sel_jpc_i = Input(UInt(SEL_JPC_I.width.W))
        val sel_jpc_o = Input(UInt(SEL_JPC_O.width.W))
        val pc = Input(UInt(XLEN.W))
        val rs1_data = Input(UInt(XLEN.W))
        val imm = Input(UInt(XLEN.W))
        val jmp_addr = Output(UInt(XLEN.W))
    })
    val jpc_i = WireDefault(0.U(XLEN.W))
    val jpc_o = WireDefault(0.U(XLEN.W))
    //input selection
    jpc_i := MuxLookup(io.sel_jpc_i, 0.U)(
        Seq(
            SEL_JPC_I.PC.U -> io.pc,
            SEL_JPC_I.RS1.U -> io.rs1_data
        )
    )
    //output selection
    jpc_o := MuxLookup(io.sel_jpc_o, 0.U)(
        Seq(
            SEL_JPC_O.Normal.U -> (jpc_i + io.imm),
            SEL_JPC_O.Jalr.U   -> ((jpc_i + io.imm) & (~1.U(XLEN.W)))
        )
    )
    io.jmp_addr := jpc_o
}