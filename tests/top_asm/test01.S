# RISC-V 64-bit Integer (RV64I) Arithmetic Test Code
# Only R-type and I-type instructions included.
# No Loads, Stores, Branches, or System Calls.

    # ---------------------------------------------------------
    # 1. 初始化寄存器 (使用 I-type: ADDI)
    # ---------------------------------------------------------
    addi x1, x0, 10       # x1 = 10
    addi x2, x0, -5       # x2 = -5 (补码: 0xFFFFFFFFFFFFFFFB)
    addi x3, x0, 3        # x3 = 3
    addi x4, x0, 0xFF     # x4 = 255

    # ---------------------------------------------------------
    # 2. 基础算术运算 (R-type)
    # ---------------------------------------------------------
    add  x5, x1, x2       # x5 = 10 + (-5) = 5
    sub  x6, x1, x3       # x6 = 10 - 3 = 7
    add  x7, x0, x0       # x7 = 0 (NOP equivalent)

    # ---------------------------------------------------------
    # 3. 逻辑运算 (R-type)
    # ---------------------------------------------------------
    and  x8, x1, x4       # x8 = 10 & 255 = 10
    or   x9, x1, x3       # x9 = 10 | 3   = 11 (0xA | 0x3 = 0xB)
    xor  x10, x1, x4      # x10 = 10 ^ 255 = 245
    
    # ---------------------------------------------------------
    # 4. 比较运算 (Set Less Than)
    # ---------------------------------------------------------
    slt  x11, x2, x1      # x11 = (-5 < 10) ? 1 : 0 -> 结果: 1 (有符号比较)
    sltu x12, x2, x1      # x12 = (-5 < 10) ? 1 : 0 -> 结果: 0 (无符号比较，-5是很大的正数)

    # ---------------------------------------------------------
    # 5. 立即数运算 (I-type)
    # ---------------------------------------------------------
    addi x13, x1, 20      # x13 = 10 + 20 = 30
    andi x14, x4, 0x0F    # x14 = 0xFF & 0x0F = 0x0F (15)
    ori  x15, x3, 0x10    # x15 = 3 | 16 = 19
    xori x16, x3, -1      # x16 = ~3 (按位取反)
    slti x17, x2, -1      # x17 = (-5 < -1) ? 1 : 0 -> 结果: 1

    # ---------------------------------------------------------
    # 6. 移位运算 (Shift Operations)
    # ---------------------------------------------------------
    # 逻辑左移 (Shift Left Logical)
    slli x18, x1, 2       # x18 = 10 << 2 = 40
    sll  x19, x1, x3      # x19 = 10 << 3 = 80
    
    # 逻辑右移 (Shift Right Logical)
    srli x20, x4, 4       # x20 = 0xFF >> 4 = 0x0F
    srl  x21, x4, x3      # x21 = 0xFF >> 3 = 0x1F

    # 算术右移 (Shift Right Arithmetic - 保留符号位)
    srai x22, x2, 1       # x22 = -5 >> 1 = -3 (0xFF...FB -> 0xFF...FD)
    sra  x23, x2, x3      # x23 = -5 >> 3 = -1

    # ---------------------------------------------------------
    # 7. RV64 特有指令 (32-bit Word Operations)
    # 这些指令会对结果进行符号扩展 (Sign-extend to 64-bit)
    # ---------------------------------------------------------
    # 准备大数用于测试截断
    addi x24, x0, 1
    slli x24, x24, 31     # x24 = 0x80000000 (32-bit INT_MIN)
    addi x25, x0, 1       # x25 = 1

    addw x26, x24, x25    # x26 = (int32)0x80000000 + 1 = 0x80000001 -> 符号扩展 -> 0xFFFFFFFF80000001
    subw x27, x1, x3      # x27 = 10 - 3 = 7 -> 0x0000000000000007
    addiw x28, x24, -1    # x28 = 0x80000000 + (-1) = 0x7FFFFFFF -> 0x000000007FFFFFFF

    slliw x29, x3, 1      # x29 = 3 << 1 = 6 (按32位操作)
    srliw x30, x4, 1      # x30 = 255 >> 1 = 127
    sraiw x31, x2, 1      # x31 = -5 >> 1 (32位算术右移) -> 符号扩展

